package output

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/dqix-org/dqix/internal/core"
	"github.com/fatih/color"
)

type Formatter interface {
	Output(result *core.AssessmentResult) error
}

type JSONFormatter struct{}
type CSVFormatter struct{}
type ReportFormatter struct{}

func NewFormatter(format string) Formatter {
	switch strings.ToLower(format) {
	case "csv":
		return &CSVFormatter{}
	case "report":
		return &ReportFormatter{}
	default:
		return &JSONFormatter{}
	}
}

func (f *JSONFormatter) Output(result *core.AssessmentResult) error {
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return err
	}
	fmt.Println(string(data))
	return nil
}

func (f *CSVFormatter) Output(result *core.AssessmentResult) error {
	writer := csv.NewWriter(os.Stdout)
	defer writer.Flush()

	// Headers
	headers := []string{"Domain", "Overall Score", "Level", "Timestamp", "Duration"}
	for probeName := range result.ProbeResults {
		headers = append(headers, probeName+" Score")
		headers = append(headers, probeName+" Status")
	}
	writer.Write(headers)

	// Data
	row := []string{
		result.Domain,
		fmt.Sprintf("%.4f", result.Score),
		result.Level,
		result.Timestamp.Format(time.RFC3339),
		result.Duration.String(),
	}

	for _, probeResult := range result.ProbeResults {
		row = append(row, fmt.Sprintf("%.4f", probeResult.Score))
		row = append(row, probeResult.Status)
	}
	
	writer.Write(row)
	return nil
}

func (f *ReportFormatter) Output(result *core.AssessmentResult) error {
	// Header
	color.Cyan("🔍 DQIX Assessment Report (Go Implementation)")
	color.Cyan("=" + strings.Repeat("=", 50))
	fmt.Println()

	// Basic info
	color.Green("📊 Assessment Summary:")
	fmt.Printf("  Domain: %s\n", result.Domain)
	fmt.Printf("  Overall Score: %.4f/1.0000\n", result.Score)
	fmt.Printf("  Quality Level: %s\n", result.Level)
	fmt.Printf("  Assessment Time: %s\n", result.Timestamp.Format("2006-01-02 15:04:05"))
	fmt.Printf("  Duration: %s\n", result.Duration)
	fmt.Printf("  Implementation: %s\n", result.Metadata["implementation"])
	fmt.Printf("  Version: %s\n", result.Metadata["version"])
	fmt.Println()

	// Probe details
	color.Yellow("🔧 Probe Results:")
	for name, probeResult := range result.ProbeResults {
		status := "✅"
		if probeResult.Status != "success" {
			status = "❌"
		}
		
		color.White("  %s %s:", status, name)
		fmt.Printf("    Score: %.4f/1.0000\n", probeResult.Score)
		fmt.Printf("    Status: %s\n", probeResult.Status)
		fmt.Printf("    Duration: %s\n", probeResult.Duration)
		
		if probeResult.Error != "" {
			color.Red("    Error: %s", probeResult.Error)
		}
		
		if len(probeResult.Details) > 0 {
			fmt.Printf("    Details:\n")
			for key, value := range probeResult.Details {
				fmt.Printf("      %s: %v\n", key, value)
			}
		}
		fmt.Println()
	}

	// Level explanation
	color.Magenta("📈 Quality Level Guide:")
	levels := map[string]string{
		"A+": "95-100% - Exceptional security and compliance",
		"A":  "85-94% - Excellent security posture",
		"B":  "75-84% - Good security with minor improvements needed",
		"C":  "65-74% - Adequate security with several improvements needed",
		"D":  "55-64% - Below average security, significant improvements required",
		"E":  "45-54% - Poor security posture, immediate attention required",
		"F":  "0-44% - Critical security issues, urgent action required",
	}
	
	for level, description := range levels {
		marker := "  "
		if level == result.Level {
			marker = "→ "
			color.Green("%s%s: %s", marker, level, description)
		} else {
			fmt.Printf("%s%s: %s\n", marker, level, description)
		}
	}
	
	fmt.Println()
	color.Cyan("Generated by DQIX Go Implementation v%s", result.Metadata["version"])
	
	return nil
} 