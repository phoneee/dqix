#!/usr/bin/env bash

# DQIX Internet Observability Platform - Complete Bash Implementation
# Feature-complete implementation with all probe functionality

set -euo pipefail

# Global constants
readonly SCRIPT_NAME="$(basename "$0")"
readonly VERSION="2.0.0"
readonly TIMESTAMP="$(date +%s)"

# Color definitions
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[0;37m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly ENGINE="Bash DQIX v${VERSION}"
readonly TIMEOUT=30

# Initialize probe data arrays (bash 3.2 compatible)
PROBE_NAMES=()
PROBE_SCORES=()
PROBE_DETAILS=()
PROBE_CATEGORIES=()

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${RESET} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${RESET} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${RESET} $*"
}

# Domain validation
validate_domain() {
    local domain="$1"
    
    if [[ -z "$domain" ]]; then
        log_error "Domain name cannot be empty"
        return 1
    fi
    
    if [[ "$domain" != *.* ]]; then
        log_error "Domain name must contain at least one dot"
        return 1
    fi
    
    if [[ ${#domain} -gt 253 ]]; then
        log_error "Domain name too long"
        return 1
    fi
    
    # Basic regex validation
    if ! [[ "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        log_error "Invalid domain format"
        return 1
    fi
    
    return 0
}

# Global variables for SSL analysis (bash 3.2 compatible)
SSL_PROTOCOL_SCORE=0
SSL_CERT_SCORE=0
SSL_CIPHER_SCORE=0
SSL_VULN_SCORE=0
SSL_SUPPORTED_PROTOCOLS=""
SSL_KEY_SIZE=""
SSL_SIG_ALGORITHM=""
SSL_STRONG_CIPHERS=0
SSL_WEAK_CIPHERS=0
SSL_VULNERABILITIES=""

# Comprehensive SSL/TLS Analysis Functions

# Basic TLS probe (existing functionality)
probe_tls() {
    local domain="$1"
    local score=0
    local details=""
    
    # Check TLS using openssl
    local tls_info
    if tls_info=$(timeout "$TIMEOUT" openssl s_client -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null); then
        # Extract protocol version
        local protocol
        protocol=$(echo "$tls_info" | grep -m1 "Protocol" | awk '{print $3}')
        
        # Score based on protocol
        case "$protocol" in
            TLSv1.3) score=100 ;;
            TLSv1.2) score=85 ;;
            TLSv1.1) score=60 ;;
            TLSv1|SSLv*) score=30 ;;
            *) score=50 ;;
        esac
        
        # Check certificate validity
        if echo "$tls_info" | grep -q "Verify return code: 0"; then
            details="Valid certificate, $protocol"
        else
            score=$((score - 20))
            details="Certificate issues, $protocol"
        fi
    else
        score=0
        details="TLS connection failed"
    fi
    
    echo "$score|$details"
}

# Enhanced SSL Labs-style analysis
probe_ssl_comprehensive() {
    local domain="$1"
    local full_analysis="${2:-false}"
    
    if [[ "$full_analysis" != "true" ]]; then
        probe_tls "$domain"
        return
    fi
    
    local overall_score=0
    local details=""
    
    # Clear previous SSL analysis data
    SSL_PROTOCOL_SCORE=0
    SSL_CERT_SCORE=0
    SSL_CIPHER_SCORE=0
    SSL_VULN_SCORE=0
    SSL_SUPPORTED_PROTOCOLS=""
    SSL_KEY_SIZE=""
    SSL_SIG_ALGORITHM=""
    SSL_STRONG_CIPHERS=0
    SSL_WEAK_CIPHERS=0
    SSL_VULNERABILITIES=""
    
    # Protocol Support Analysis
    analyze_protocol_support "$domain"
    
    # Certificate Analysis
    analyze_certificate "$domain"
    
    # Cipher Suite Analysis
    analyze_cipher_suites "$domain"
    
    # Vulnerability Analysis
    analyze_vulnerabilities "$domain"
    
    # Calculate weighted overall score
    overall_score=$(( (SSL_PROTOCOL_SCORE * 30 + SSL_CERT_SCORE * 30 + SSL_CIPHER_SCORE * 25 + SSL_VULN_SCORE * 15) / 100 ))
    
    # Generate comprehensive details
    details="SSL Labs-style: Overall ${overall_score}%, "
    details+="Proto ${SSL_PROTOCOL_SCORE}%, Cert ${SSL_CERT_SCORE}%, "
    details+="Cipher ${SSL_CIPHER_SCORE}%, Vuln ${SSL_VULN_SCORE}%"
    
    echo "$overall_score|$details"
}

# Protocol Support Analysis
analyze_protocol_support() {
    local domain="$1"
    local protocols=("ssl3" "tls1" "tls1_1" "tls1_2" "tls1_3")
    local supported_protocols=()
    local protocol_score=0
    
    for proto in "${protocols[@]}"; do
        if timeout 10 openssl s_client -"$proto" -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | grep -q "Protocol"; then
            supported_protocols+=("$proto")
        fi
    done
    
    # Score based on supported protocols
    local supported_list="${supported_protocols[*]:-}"
    if [[ " $supported_list " =~ " tls1_3 " ]]; then
        protocol_score=100
    elif [[ " $supported_list " =~ " tls1_2 " ]]; then
        protocol_score=85
    elif [[ " $supported_list " =~ " tls1_1 " ]]; then
        protocol_score=60
    elif [[ " $supported_list " =~ " tls1 " ]]; then
        protocol_score=40
    fi
    
    # Penalize for old protocols
    if [[ " $supported_list " =~ " ssl3 " ]]; then
        protocol_score=$((protocol_score - 50))
    fi
    if [[ " $supported_list " =~ " tls1 " ]] && [[ " $supported_list " =~ " tls1_2 " ]]; then
        protocol_score=$((protocol_score - 20))
    fi
    
    protocol_score=$((protocol_score > 0 ? protocol_score : 0))
    SSL_PROTOCOL_SCORE=$protocol_score
    SSL_SUPPORTED_PROTOCOLS="$supported_list"
}

# Certificate Analysis
analyze_certificate() {
    local domain="$1"
    local cert_score=100
    local cert_info
    
    # Get certificate information
    cert_info=$(timeout 15 openssl s_client -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null)
    
    if [[ -z "$cert_info" ]]; then
        SSL_CERT_SCORE=0
        return
    fi
    
    # Check certificate chain
    local cert_chain
    cert_chain=$(echo "$cert_info" | openssl x509 -noout -text 2>/dev/null)
    
    # Check key size
    local key_size
    key_size=$(echo "$cert_chain" | grep -oE "RSA Public-Key: \([0-9]+ bit\)" | grep -oE "[0-9]+")
    if [[ -n "$key_size" ]]; then
        if [[ $key_size -lt 2048 ]]; then
            cert_score=$((cert_score - 50))
        elif [[ $key_size -lt 4096 ]]; then
            cert_score=$((cert_score - 10))
        fi
    fi
    
    # Check signature algorithm
    local sig_alg
    sig_alg=$(echo "$cert_chain" | grep "Signature Algorithm" | head -1 | awk '{print $3}')
    case "$sig_alg" in
        *sha1*) cert_score=$((cert_score - 40)) ;;
        *md5*) cert_score=$((cert_score - 80)) ;;
    esac
    
    # Check certificate validity
    if ! echo "$cert_info" | grep -q "Verify return code: 0"; then
        cert_score=$((cert_score - 30))
    fi
    
    # Check for extended validation
    if echo "$cert_chain" | grep -q "Extended Validation"; then
        cert_score=$((cert_score + 5))
    fi
    
    cert_score=$((cert_score > 0 ? cert_score : 0))
    SSL_CERT_SCORE=$cert_score
    SSL_KEY_SIZE="$key_size"
    SSL_SIG_ALGORITHM="$sig_alg"
}

# Cipher Suite Analysis
analyze_cipher_suites() {
    local domain="$1"
    local cipher_score=0
    local strong_ciphers=0
    local weak_ciphers=0
    local total_ciphers=0
    
    # Test common cipher suites
    local test_ciphers=(
        "ECDHE-RSA-AES256-GCM-SHA384"
        "ECDHE-RSA-AES128-GCM-SHA256"
        "ECDHE-RSA-AES256-SHA384"
        "ECDHE-RSA-AES128-SHA256"
        "AES256-GCM-SHA384"
        "AES128-GCM-SHA256"
        "DES-CBC3-SHA"
        "RC4-SHA"
        "NULL-SHA"
    )
    
    for cipher in "${test_ciphers[@]}"; do
        if timeout 10 openssl s_client -cipher "$cipher" -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | grep -q "Cipher is"; then
            total_ciphers=$((total_ciphers + 1))
            
            case "$cipher" in
                *ECDHE*AES*GCM*) strong_ciphers=$((strong_ciphers + 1)) ;;
                *AES*GCM*) strong_ciphers=$((strong_ciphers + 1)) ;;
                *DES*|*RC4*|*NULL*) weak_ciphers=$((weak_ciphers + 1)) ;;
            esac
        fi
    done
    
    if [[ $total_ciphers -gt 0 ]]; then
        cipher_score=$(( (strong_ciphers * 100) / total_ciphers ))
        cipher_score=$((cipher_score - weak_ciphers * 30))
    fi
    
    cipher_score=$((cipher_score > 0 ? cipher_score : 0))
    cipher_score=$((cipher_score < 100 ? cipher_score : 100))
    
    SSL_CIPHER_SCORE=$cipher_score
    SSL_STRONG_CIPHERS=$strong_ciphers
    SSL_WEAK_CIPHERS=$weak_ciphers
}

# Vulnerability Analysis
analyze_vulnerabilities() {
    local domain="$1"
    local vuln_score=100
    local vulnerabilities=()
    
    # Test for Heartbleed
    if timeout 10 openssl s_client -connect "$domain:443" -servername "$domain" -tlsextdebug </dev/null 2>/dev/null | grep -q "heartbeat"; then
        # This is a simplified check - real Heartbleed testing requires specific payloads
        local heartbleed_test
        heartbleed_test=$(echo "Q" | timeout 5 openssl s_client -connect "$domain:443" -servername "$domain" 2>/dev/null)
        if [[ ${#heartbleed_test} -gt 1000 ]]; then
            vulnerabilities+=("Heartbleed")
            vuln_score=$((vuln_score - 80))
        fi
    fi
    
    # Test for POODLE (SSLv3)
    if timeout 10 openssl s_client -ssl3 -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | grep -q "Protocol.*SSLv3"; then
        vulnerabilities+=("POODLE")
        vuln_score=$((vuln_score - 60))
    fi
    
    # Test for weak cipher suites (BEAST, CRIME)
    if timeout 10 openssl s_client -cipher "RC4" -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | grep -q "Cipher is RC4"; then
        vulnerabilities+=("RC4")
        vuln_score=$((vuln_score - 40))
    fi
    
    # Test for compression (CRIME)
    local compression_test
    compression_test=$(timeout 10 openssl s_client -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | grep -i compression)
    if [[ "$compression_test" =~ "Compression: zlib" ]] || [[ "$compression_test" =~ "Compression: 1" ]]; then
        vulnerabilities+=("CRIME")
        vuln_score=$((vuln_score - 30))
    fi
    
    vuln_score=$((vuln_score > 0 ? vuln_score : 0))
    SSL_VULN_SCORE=$vuln_score
    SSL_VULNERABILITIES="${vulnerabilities[*]:-}"
}

probe_dns() {
    local domain="$1"
    local score=0
    local details=""
    
    # Check basic DNS resolution
    if host "$domain" >/dev/null 2>&1; then
        score=50
        details="DNS resolves"
        
        # Check for IPv6
        if host -t AAAA "$domain" 2>/dev/null | grep -q "has IPv6 address"; then
            score=$((score + 20))
            details="$details, IPv6"
        fi
        
        # Check for common DNS records
        if host -t MX "$domain" 2>/dev/null | grep -q "mail is handled"; then
            score=$((score + 10))
            details="$details, MX"
        fi
        
        if host -t TXT "$domain" 2>/dev/null | grep -q "text"; then
            score=$((score + 10))
            details="$details, TXT"
        fi
        
        # Check for SPF
        if host -t TXT "$domain" 2>/dev/null | grep -q "v=spf"; then
            score=$((score + 10))
            details="$details, SPF"
        fi
    else
        score=0
        details="DNS resolution failed"
    fi
    
    echo "$score|$details"
}

probe_https() {
    local domain="$1"
    local score=0
    local details=""
    
    # Check HTTPS availability
    local response
    response=$(curl -sI -m "$TIMEOUT" "https://$domain" 2>/dev/null | head -n1)
    
    if [[ -n "$response" ]]; then
        score=50
        details="HTTPS accessible"
        
        # Check for HSTS
        if curl -sI -m "$TIMEOUT" "https://$domain" 2>/dev/null | grep -qi "Strict-Transport-Security"; then
            score=$((score + 30))
            details="$details, HSTS"
        fi
        
        # Check redirect from HTTP
        local http_response
        http_response=$(curl -sI -m "$TIMEOUT" -L "http://$domain" 2>/dev/null | grep -i "Location:" | head -n1)
        
        if [[ "$http_response" =~ https:// ]]; then
            score=$((score + 20))
            details="$details, HTTP->HTTPS redirect"
        fi
    else
        score=0
        details="HTTPS not accessible"
    fi
    
    echo "$score|$details"
}

probe_headers() {
    local domain="$1"
    local score=0
    local details=""
    local headers_found=0
    
    # Get headers
    local headers
    headers=$(curl -sI -m "$TIMEOUT" "https://$domain" 2>/dev/null)
    
    if [[ -n "$headers" ]]; then
        # Check security headers
        if echo "$headers" | grep -qi "Content-Security-Policy"; then
            score=$((score + 25))
            headers_found=$((headers_found + 1))
        fi
        
        if echo "$headers" | grep -qi "X-Frame-Options"; then
            score=$((score + 25))
            headers_found=$((headers_found + 1))
        fi
        
        if echo "$headers" | grep -qi "X-Content-Type-Options"; then
            score=$((score + 25))
            headers_found=$((headers_found + 1))
        fi
        
        if echo "$headers" | grep -qi "Referrer-Policy"; then
            score=$((score + 25))
            headers_found=$((headers_found + 1))
        fi
        
        details="$headers_found security headers"
    else
        score=0
        details="Headers check failed"
    fi
    
    echo "$score|$details"
}

# Run all probes
run_probes() {
    local domain="$1"
    local full_ssl="${2:-false}"
    
    # Clear previous results
    PROBE_NAMES=()
    PROBE_SCORES=()
    PROBE_DETAILS=()
    PROBE_CATEGORIES=()
    
    # Run TLS probe (basic or comprehensive)
    local tls_result
    if [[ "$full_ssl" == "true" ]]; then
        tls_result=$(probe_ssl_comprehensive "$domain" "true")
    else
        tls_result=$(probe_tls "$domain")
    fi
    PROBE_NAMES+=("tls")
    PROBE_SCORES+=("$(echo "$tls_result" | cut -d'|' -f1)")
    PROBE_DETAILS+=("$(echo "$tls_result" | cut -d'|' -f2-)")
    PROBE_CATEGORIES+=("security")
    
    # Run DNS probe
    local dns_result
    dns_result=$(probe_dns "$domain")
    PROBE_NAMES+=("dns")
    PROBE_SCORES+=("$(echo "$dns_result" | cut -d'|' -f1)")
    PROBE_DETAILS+=("$(echo "$dns_result" | cut -d'|' -f2-)")
    PROBE_CATEGORIES+=("infrastructure")
    
    # Run HTTPS probe
    local https_result
    https_result=$(probe_https "$domain")
    PROBE_NAMES+=("https")
    PROBE_SCORES+=("$(echo "$https_result" | cut -d'|' -f1)")
    PROBE_DETAILS+=("$(echo "$https_result" | cut -d'|' -f2-)")
    PROBE_CATEGORIES+=("protocol")
    
    # Run Headers probe
    local headers_result
    headers_result=$(probe_headers "$domain")
    PROBE_NAMES+=("headers")
    PROBE_SCORES+=("$(echo "$headers_result" | cut -d'|' -f1)")
    PROBE_DETAILS+=("$(echo "$headers_result" | cut -d'|' -f2-)")
    PROBE_CATEGORIES+=("security")
}

# Calculate overall score
calculate_overall_score() {
    local tls_weight=35
    local dns_weight=25
    local https_weight=20
    local headers_weight=20
    
    local total=0
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        local score="${PROBE_SCORES[$i]}"
        local weight=0
        
        case "$name" in
            tls) weight=$tls_weight ;;
            dns) weight=$dns_weight ;;
            https) weight=$https_weight ;;
            headers) weight=$headers_weight ;;
        esac
        
        total=$((total + score * weight / 100))
    done
    
    echo "$total"
}

# Get security grade
get_security_grade() {
    local score="$1"
    
    if [[ $score -ge 95 ]]; then
        echo "A+"
    elif [[ $score -ge 90 ]]; then
        echo "A"
    elif [[ $score -ge 85 ]]; then
        echo "A-"
    elif [[ $score -ge 80 ]]; then
        echo "B+"
    elif [[ $score -ge 75 ]]; then
        echo "B"
    elif [[ $score -ge 70 ]]; then
        echo "B-"
    elif [[ $score -ge 65 ]]; then
        echo "C+"
    elif [[ $score -ge 60 ]]; then
        echo "C"
    elif [[ $score -ge 55 ]]; then
        echo "C-"
    elif [[ $score -ge 50 ]]; then
        echo "D"
    else
        echo "F"
    fi
}

# Display single probe result
display_single_probe() {
    local i="$1"
    local name="${PROBE_NAMES[$i]}"
    local score="${PROBE_SCORES[$i]}"
    local details="${PROBE_DETAILS[$i]}"
    local category="${PROBE_CATEGORIES[$i]}"
    
    # Icon based on probe
    local icon=""
    case "$name" in
        tls) icon="üîê" ;;
        dns) icon="üåç" ;;
        https) icon="üåê" ;;
        headers) icon="üõ°Ô∏è" ;;
        *) icon="üîç" ;;
    esac
    
    # Color based on score
    local color=""
    if [[ $score -ge 80 ]]; then
        color="$GREEN"
    elif [[ $score -ge 60 ]]; then
        color="$YELLOW"
    else
        color="$RED"
    fi
    
    # Score bar
    local probe_bar_length=$((score * 20 / 100))
    local probe_empty_length=$((20 - probe_bar_length))
    local probe_bar=""
    local probe_empty=""
    
    for ((j=0; j<probe_bar_length; j++)); do probe_bar="${probe_bar}‚ñà"; done
    for ((j=0; j<probe_empty_length; j++)); do probe_empty="${probe_empty}‚ñë"; done
    
    # Capitalize first letter (bash 3.2 compatible)
    local name_cap
    case "$name" in
        tls) name_cap="TLS Security" ;;
        dns) name_cap="DNS Security" ;;
        https) name_cap="HTTPS Config" ;;
        headers) name_cap="Security Headers" ;;
        *) name_cap="$name" ;;
    esac
    
    echo -e "  $icon $(printf "%-20s" "$name_cap") $color$(printf "%3d" "$score")%$RESET [$color$probe_bar$RESET$probe_empty] $details"
}

# Display results
display_results() {
    local domain="$1"
    local overall_score="$2"
    local grade="$3"
    
    echo
    echo -e "${BOLD}${BLUE}üîç DQIX Internet Observability Platform${RESET}"
    echo -e "Analyzing: ${BOLD}$domain${RESET}"
    echo
    
    # Overall score bar
    local bar_length=$((overall_score * 40 / 100))
    local empty_length=$((40 - bar_length))
    local bar=""
    local empty=""
    
    for ((i=0; i<bar_length; i++)); do bar="${bar}‚ñà"; done
    for ((i=0; i<empty_length; i++)); do empty="${empty}‚ñë"; done
    
    echo -e "${BOLD}Overall Score: ${overall_score}% ${grade}${RESET}"
    echo -e "[${GREEN}${bar}${RESET}${empty}]"
    echo
    
    # 3-Level Probe Display
    echo -e "${BOLD}Security Assessment (3-Level Hierarchy):${RESET}"
    echo
    
    # Level 1: Critical Security (TLS, Headers)
    echo -e "${BOLD}${RED}üö® CRITICAL SECURITY${RESET}"
    echo -e "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Display critical probes sorted by score (lowest first)
    local critical_displayed=0
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        if [[ "$name" == "tls" || "$name" == "headers" ]]; then
            display_single_probe "$i"
            critical_displayed=1
        fi
    done
    [[ $critical_displayed -eq 1 ]] && echo
    
    # Level 2: Important Configuration (HTTPS, DNS core)
    echo -e "${BOLD}${YELLOW}‚ö†Ô∏è  IMPORTANT CONFIGURATION${RESET}"
    echo -e "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    local important_displayed=0
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        if [[ "$name" == "https" || "$name" == "dns" ]]; then
            display_single_probe "$i"
            important_displayed=1
        fi
    done
    [[ $important_displayed -eq 1 ]] && echo
    
    # Level 3: Best Practices (any additional probes)
    local has_additional=0
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        if [[ "$name" != "tls" && "$name" != "headers" && "$name" != "https" && "$name" != "dns" ]]; then
            has_additional=1
            break
        fi
    done
    
    if [[ $has_additional -eq 1 ]]; then
        echo -e "${BOLD}${BLUE}‚ÑπÔ∏è  BEST PRACTICES${RESET}"
        echo -e "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        
        for i in "${!PROBE_NAMES[@]}"; do
            local name="${PROBE_NAMES[$i]}"
            if [[ "$name" != "tls" && "$name" != "headers" && "$name" != "https" && "$name" != "dns" ]]; then
                display_single_probe "$i"
            fi
        done
        echo
    fi
    
    echo
    echo -e "${BOLD}Recommendations:${RESET}"
    
    # Generate recommendations based on scores
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        local score="${PROBE_SCORES[$i]}"
        
        if [[ $score -lt 80 ]]; then
            case "$name" in
                tls)
                    echo "  ‚Ä¢ Upgrade to TLS 1.3 for better security"
                    ;;
                dns)
                    echo "  ‚Ä¢ Consider adding IPv6 support and DNSSEC"
                    ;;
                https)
                    echo "  ‚Ä¢ Implement HSTS and ensure HTTP redirects to HTTPS"
                    ;;
                headers)
                    echo "  ‚Ä¢ Add security headers (CSP, X-Frame-Options, etc.)"
                    ;;
            esac
        fi
    done
}

# Display SSL Labs-style detailed results
display_ssl_details() {
    local domain="$1"
    
    echo
    echo -e "${BOLD}${BLUE}üîç SSL Labs-Style Comprehensive Analysis${RESET}"
    echo -e "Domain: ${BOLD}$domain${RESET}"
    echo
    
    # Protocol Support
    echo -e "${BOLD}${CYAN}Protocol Support:${RESET}"
    if [[ -n "$SSL_SUPPORTED_PROTOCOLS" ]]; then
        echo "  Supported: $SSL_SUPPORTED_PROTOCOLS"
        echo "  Score: ${SSL_PROTOCOL_SCORE}%"
    else
        echo "  No protocols detected"
    fi
    echo
    
    # Certificate Information
    echo -e "${BOLD}${CYAN}Certificate:${RESET}"
    if [[ -n "$SSL_KEY_SIZE" ]]; then
        echo "  Key Size: ${SSL_KEY_SIZE} bits"
    fi
    if [[ -n "$SSL_SIG_ALGORITHM" ]]; then
        echo "  Signature Algorithm: $SSL_SIG_ALGORITHM"
    fi
    echo "  Score: ${SSL_CERT_SCORE}%"
    echo
    
    # Cipher Suites
    echo -e "${BOLD}${CYAN}Cipher Suites:${RESET}"
    echo "  Strong Ciphers: $SSL_STRONG_CIPHERS"
    echo "  Weak Ciphers: $SSL_WEAK_CIPHERS"
    echo "  Score: ${SSL_CIPHER_SCORE}%"
    echo
    
    # Vulnerabilities
    echo -e "${BOLD}${CYAN}Vulnerabilities:${RESET}"
    if [[ -n "$SSL_VULNERABILITIES" && "$SSL_VULNERABILITIES" != " " ]]; then
        echo "  Found: $SSL_VULNERABILITIES"
    else
        echo "  None detected"
    fi
    echo "  Score: ${SSL_VULN_SCORE}%"
    echo
}

# Command handlers
handle_scan() {
    local domain="$1"
    local full_ssl_flag="false"
    local json_flag="false"
    
    # Parse flags
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --full-ssl) full_ssl_flag="true" ;;
            --json) json_flag="true" ;;
            *) echo "Unknown flag: $1" >&2; return 1 ;;
        esac
        shift
    done
    
    if ! validate_domain "$domain"; then
        return 1
    fi
    
    if [[ "$full_ssl_flag" == "true" ]]; then
        log_info "Running comprehensive SSL Labs-style scan on $domain..."
    else
        log_info "Scanning $domain..."
    fi
    
    # Run probes
    run_probes "$domain" "$full_ssl_flag"
    
    # Calculate overall score
    local overall_score
    overall_score=$(calculate_overall_score)
    
    # Get grade
    local grade
    grade=$(get_security_grade "$overall_score")
    
    # Display results
    display_results "$domain" "$overall_score" "$grade"
    
    # Display detailed SSL analysis if requested
    if [[ "$full_ssl_flag" == "true" ]]; then
        display_ssl_details "$domain"
    fi
    
    # Generate JSON output if requested
    if [[ "$json_flag" == "true" ]]; then
        generate_json_output "$domain" "$overall_score" "$grade"
    fi
}

handle_validate() {
    local domain="$1"
    
    if ! validate_domain "$domain"; then
        return 1
    fi
    
    log_info "Validating $domain..."
    
    # Run probes
    run_probes "$domain"
    
    # Display validation checklist
    echo
    echo -e "${BOLD}üîç Security Validation Checklist${RESET}"
    echo -e "Domain: ${BOLD}$domain${RESET}"
    echo
    
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        local score="${PROBE_SCORES[$i]}"
        local status="‚ùå"
        
        if [[ $score -ge 80 ]]; then
            status="‚úÖ"
        elif [[ $score -ge 60 ]]; then
            status="‚ö†Ô∏è"
        fi
        
        # Capitalize first letter (bash 3.2 compatible)
        local name_cap
        case "$name" in
            tls) name_cap="TLS" ;;
            dns) name_cap="DNS" ;;
            https) name_cap="HTTPS" ;;
            headers) name_cap="Headers" ;;
            *) name_cap="$name" ;;
        esac
        printf "  %s %-20s %3d%%\n" "$status" "$name_cap Security" "$score"
    done
}

handle_test() {
    echo -e "${BOLD}üß™ Running DQIX Tests${RESET}"
    echo
    
    local test_domains=("github.com" "google.com" "example.com")
    
    for domain in "${test_domains[@]}"; do
        echo -e "${BOLD}Testing $domain:${RESET}"
        
        if validate_domain "$domain"; then
            run_probes "$domain"
            local score
            score=$(calculate_overall_score)
            echo "  ‚úÖ Overall score: ${score}%"
        else
            echo "  ‚ùå Validation failed"
        fi
        echo
    done
}

handle_demo() {
    local domain="${1:-github.com}"
    
    echo -e "${BOLD}üéØ DQIX Demo Mode${RESET}"
    echo
    echo "This is a demonstration of DQIX capabilities."
    echo "Analyzing: $domain"
    echo
    
    # Simulate scanning with progress
    local steps=("Connecting to domain" "Checking TLS/SSL" "Analyzing DNS" "Testing HTTPS" "Scanning headers")
    
    for step in "${steps[@]}"; do
        echo -n "  $step"
        for i in {1..3}; do
            sleep 0.3
            echo -n "."
        done
        echo " ‚úì"
    done
    
    echo
    handle_scan "$domain"
}

# Generate JSON output
generate_json_output() {
    local domain="$1"
    local overall_score="$2"
    local grade="$3"
    
    cat <<EOF
{
  "domain": "$domain",
  "overall_score": $overall_score,
  "grade": "$grade",
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "engine": "$ENGINE",
  "probe_results": [
EOF
    
    for i in "${!PROBE_NAMES[@]}"; do
        local name="${PROBE_NAMES[$i]}"
        local score="${PROBE_SCORES[$i]}"
        local details="${PROBE_DETAILS[$i]}"
        local category="${PROBE_CATEGORIES[$i]}"
        
        cat <<EOF
    {
      "probe_id": "$name",
      "score": $score,
      "category": "$category",
      "details": "$details"
    }$(if [[ $i -lt $((${#PROBE_NAMES[@]} - 1)) ]]; then echo ","; fi)
EOF
    done
    
    cat <<EOF
  ]
}
EOF
}

# Show help
show_help() {
    cat <<EOF
DQIX Internet Observability Platform - Bash Implementation

Usage: $SCRIPT_NAME <command> [options]

Commands:
  scan <domain>      Comprehensive domain security scan
  validate <domain>  Security validation checklist
  test              Run tests on sample domains
  demo [domain]     Interactive demonstration
  help              Show this help message
  version           Show version information

Options:
  --json            Output results in JSON format
  --full-ssl        Enable comprehensive SSL Labs-style SSL/TLS analysis
                    (includes protocol analysis, certificate validation,
                     cipher suite evaluation, and vulnerability scanning)

Examples:
  $SCRIPT_NAME scan github.com
  $SCRIPT_NAME scan github.com --full-ssl
  $SCRIPT_NAME scan example.com --json
  $SCRIPT_NAME scan example.com --full-ssl --json
  $SCRIPT_NAME validate google.com
  $SCRIPT_NAME test
  $SCRIPT_NAME demo

SSL Labs-style Analysis:
  The --full-ssl flag provides comprehensive SSL/TLS security analysis similar
  to SSL Labs, including:
  ‚Ä¢ Protocol version support (SSL 3.0, TLS 1.0-1.3)
  ‚Ä¢ Certificate chain validation and key strength analysis
  ‚Ä¢ Cipher suite strength evaluation
  ‚Ä¢ Vulnerability detection (Heartbleed, POODLE, CRIME, etc.)
  ‚Ä¢ Detailed scoring breakdown

For more information, visit: https://github.com/phoneee/dqix
EOF
}

# Main function
main() {
    case "${1:-help}" in
        scan)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: $SCRIPT_NAME scan <domain> [--full-ssl] [--json]"
                exit 1
            fi
            # Pass all arguments starting from domain to handle_scan
            handle_scan "${@:2}"
            ;;
        validate)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: $SCRIPT_NAME validate <domain>"
                exit 1
            fi
            handle_validate "$2"
            ;;
        test)
            handle_test
            ;;
        demo)
            handle_demo "${2:-}"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-v)
            echo "DQIX $VERSION - Bash Implementation"
            ;;
        *)
            log_error "Unknown command: $1"
            show_help
            exit 1
            ;;
    esac
}

# Execute main with all arguments
main "$@"